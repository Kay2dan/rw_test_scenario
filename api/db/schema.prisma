// datasource db {
//   provider = "sqlite"
//   url      = env("DATABASE_URL")
// }

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider      = "prisma-client-js"
  binaryTargets = "native"
}

model User {
  id                  String         @id @default(cuid())
  createdAt           DateTime       @default(now())
  updatedAt           DateTime       @updatedAt
  firstName           String?
  lastName            String?
  email               String         @unique
  hashedPassword      String?
  salt                String
  resetToken          String?
  resetTokenExpiresAt DateTime?
  role                String         @default("user")
  profile             Profile?
  // sessions        Session[]
  teamAsUser1         Team[]         @relation("user1")
  teamAsUser2         Team[]         @relation("user2")
  goalBoard           GoalBoard[]
  chore               Chore[]
  goal                Goal[]
  task                Task[]
  comment             Comment[]
  teamMessage         TeamMessage[]
  // Activities      Activities[]
  // weekReview      WeekReview[]
  // appFeedback     AppFeedback[]
  // questionaireAns QuestionaireAnswer[]
  log                 Log[]          @relation("owner")
  noticeTo            Notification[] @relation("noticeTo")
  noticeFrom          Notification[] @relation("noticeFrom")
  callFrom            Meeting[]      @relation("callFrom")
  callTo              Meeting[]      @relation("callTo")
}

model Profile {
  id               String  @id @default(cuid())
  aboutMe          String?
  avatar           String?
  missionStatement String?
  motivation       String?
  gender           String?
  location         String?
  timeZoneUTC      String?
  profession       String?
  user             User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId           String

  @@unique([userId])
}

model Team {
  id                    String         @id @default(cuid())
  startDate             DateTime
  endDate               DateTime
  isActive              Boolean        @default(true)
  // member      User[]
  user1                 User           @relation(name: "user1", fields: [user1Id], references: [id], onDelete: Cascade)
  user1Id               String
  user2                 User           @relation(name: "user2", fields: [user2Id], references: [id], onDelete: Cascade)
  user2Id               String
  u1PostGraceStayInTeam OptionYesNo    @default(NOTSET)
  u2PostGraceStayInTeam OptionYesNo    @default(NOTSET)
  goalBoard             GoalBoard[] //relation to  GoalBoard of each of 2 members
  teamMessage           TeamMessage[]
  comment               Comment[]
  meeting               Meeting[]
  // weekReview            WeekReview[]
  log                   Log[]
  notification          Notification[]
}

model GoalBoard {
  id             String    @id @default(cuid())
  isActive       Boolean   @default(true)
  createdAt      DateTime  @default(now())
  expiresAt      DateTime?
  goal           Goal[]
  chore          Chore[]
  goalOwner      User      @relation(fields: [goalOwnerId], references: [id], onDelete: Cascade)
  goalOwnerId    String
  // weekReview     WeekReview[] @relation("gB")
  team           Team?     @relation(fields: [teamId], references: [id])
  teamId         String?
  inviteSent     Invite[]  @relation("inviteFromGB")
  inviteReceived Invite[]  @relation("inviteToGB")
  callReqSentBy  Meeting[] @relation("reqByGB")
  callReqSentTo  Meeting[] @relation("reqToGB")

  // @@unique([goalOwnerId, isActive])
}

model Invite {
  id           String    @id @default(cuid())
  fromGB       GoalBoard @relation("inviteFromGB", fields: [fromGBId], references: [id], onDelete: Cascade)
  fromGBId     String
  toGB         GoalBoard @relation("inviteToGB", fields: [toGBId], references: [id], onDelete: Cascade)
  toGBId       String
  isAccepted   Boolean   @default(false)
  isValid      Boolean   @default(true) // is still relevant or expired?
  dateSent     DateTime  @default(now())
  dateAccepted DateTime?

  @@unique([fromGBId, toGBId])
}

model Chore {
  createdAt   DateTime  @default(now())
  forDate     DateTime?
  isDisabled  Boolean   @default(false) // is past its `forDate`
  completedOn DateTime?
  goalBoard   GoalBoard @relation(fields: [goalBoardId], references: [id], onDelete: Cascade)
  goalBoardId String
  id          String    @id @default(cuid())
  order       Int?
  owner       User      @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId     String
  content     String
  // callFromChore MeetingGoal[] @relation("callFromChore")
  // callToChore   MeetingGoal[] @relation("callToChore")
  log         Log[]
  // comment     Comment[]
  // endDate     DateTime?
  // deadline    DateTime?
}

model Goal {
  createdAt   DateTime        @default(now())
  privilege   OptionPrivilege @default(PUBLIC)
  startDate   DateTime? // when the goal starts from
  endDate     DateTime? // when last task is complete, goal completed
  deadline    DateTime?
  goalBoard   GoalBoard       @relation(fields: [goalBoardId], references: [id], onDelete: Cascade)
  goalBoardId String
  id          String          @id @default(cuid())
  order       Int?
  type        GoalType?       @default(ONEOFF)
  owner       User            @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId     String
  task        Task[]
  title       String
  intro       String?
  comment     Comment[]
  log         Log[]
  // callFromGoal MeetingGoal[] @relation("callFromGoal")
  // callToGoal   MeetingGoal[] @relation("callToGoal")
  // weekReview     WeekReview[]
}

model Task {
  order         Int?
  content       String
  createdAt     DateTime        @default(now())
  startDate     DateTime?
  endDate       DateTime?
  goal          Goal?           @relation(fields: [goalId], references: [id], onDelete: Cascade)
  goalId        String?
  timeEst       Int             @default(0)
  dayFrequency  Int             @default(0)
  weekFrequency Int             @default(0)
  taskFrequency TaskFrequency[]
  id            String          @id @default(cuid())
  owner         User            @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId       String
  comment       Comment[]
  log           Log[]
  // pomodoro      Pomodoro[]
  // weekReview       WeekReview[]
}

model TaskFrequency {
  task         Task             @relation(fields: [taskId], references: [id], onDelete: Cascade)
  taskId       String
  forDate      DateTime? // for frequent tasks
  completedOn  DateTime? // for frequent tasks
  sessionStart DateTime? // for pomodoro sessions
  sessionEnd   DateTime? // for pomodoro sessions; used for both freq & one-off
  state        OneOffTaskState? // for oneoff tasks
  id           String           @id @default(cuid())
  log          Log[]

  // @@unique([taskId, completedOn])
}

model TeamMessage {
  id          String        @id @default(cuid())
  timeStamp   DateTime      @default(now())
  message     String
  msgFeedback String?
  msgReply    TeamMessage[] @relation("reply")
  msgQuote    TeamMessage?  @relation("reply", fields: [msgQuoteId], references: [id], onDelete: Cascade)
  msgQuoteId  String?
  readAt      DateTime?
  team        Team          @relation(fields: [teamId], references: [id], onDelete: Cascade)
  teamId      String
  owner       User          @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId     String
  meeting     Meeting?      @relation(fields: [meetingId], references: [id], onDelete: Cascade)
  meetingId   String?
  log         Log[]
}

model Comment {
  id          String    @id @default(cuid())
  timeStamp   DateTime  @default(now())
  message     String
  msgFeedback String?
  readAt      DateTime?
  team        Team      @relation(fields: [teamId], references: [id], onDelete: Cascade)
  teamId      String
  goal        Goal?     @relation(fields: [goalId], references: [id], onDelete: Cascade)
  goalId      String?
  task        Task?     @relation(fields: [taskId], references: [id], onDelete: Cascade)
  taskId      String?
  owner       User      @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId     String
  log         Log[]
}

model Meeting {
  id           String        @id @default(cuid())
  timeStamp    DateTime      @default(now())
  isAccepted   Boolean       @default(false)
  isValid      Boolean       @default(true) // is relevant or expired/ cancelled?
  dateAccepted DateTime?
  duration     CallLength    @default(min25)
  callStart    DateTime
  callEnd      DateTime
  callFrAttend Boolean?
  callToAttend Boolean?
  callFrom     User[]        @relation("callFrom")
  callTo       User[]        @relation("callTo")
  gBFrom       GoalBoard[]   @relation("reqByGB")
  gBTo         GoalBoard[]   @relation("reqToGB")
  team         Team?         @relation(fields: [teamId], references: [id], onDelete: Cascade)
  teamId       String?
  // meetingGoal  MeetingGoal?
  teamMessage  TeamMessage[]
  log          Log?
}

// captures user actions to display to the team
model Log {
  id              String         @id @default(cuid())
  actType         ActivityType   @default(OTHER)
  timeStamp       DateTime       @default(now())
  team            Team?          @relation(fields: [teamId], references: [id], onDelete: Cascade)
  teamId          String?
  owner           User           @relation("owner", fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId         String
  goal            Goal?          @relation(fields: [goalId], references: [id], onDelete: Cascade)
  goalId          String?
  task            Task?          @relation(fields: [taskId], references: [id], onDelete: Cascade)
  taskId          String?
  chore           Chore?         @relation(fields: [choreId], references: [id], onDelete: Cascade)
  choreId         String?
  taskFrequency   TaskFrequency? @relation(fields: [taskFrequencyId], references: [id], onDelete: Cascade)
  taskFrequencyId String?
  // wkReview        WeekReview?    @relation(fields: [wkReviewId], references: [id], onDelete: Cascade)
  // wkReviewId      String?
  teamMessage     TeamMessage?   @relation(fields: [teamMessageId], references: [id], onDelete: Cascade)
  teamMessageId   String?
  comment         Comment?       @relation(fields: [commentId], references: [id], onDelete: Cascade)
  commentId       String?
  meeting         Meeting?       @relation(fields: [meetingId], references: [id], onDelete: Cascade)
  meetingId       String?        @unique
  // question        Questionaire?  @relation(fields: [questionId], references: [id], onDelete: Cascade)
  // questionId      String?
  notification    Notification?
}

model Notification {
  id         String       @id @default(cuid())
  timeStamp  DateTime     @default(now())
  readAt     DateTime? // read by team-mate or not
  actType    ActivityType @default(OTHER)
  team       Team?        @relation(fields: [teamId], references: [id])
  teamId     String?
  owner      User         @relation("noticeFrom", fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId    String
  noticeTo   User?        @relation("noticeTo", fields: [noticeToId], references: [id], onDelete: Cascade)
  noticeToId String?
  noticeMsg  String? // text to display in notifications
  log        Log?         @relation(fields: [logId], references: [id], onDelete: Cascade)
  logId      String?      @unique
  notifyUser Boolean      @default(true)
}

enum GoalType {
  ONEOFF
  FREQUENT
}

enum ActivityType {
  EDIT // goal/task related
  OTHER // misc
  VERIFY // verify user account
  CREATE // goal/task related
  UPDATE // goal/task frequency related
  DELETE // goal/task related
  FINISH // goal/task related
  INVITE // invites received
  MEETING // meeting related
  MESSAGE //  team messages/ comments
  TEAMSTART // team start
  TEAMEND // team end
  QUESTIONAIRE // for questionaire notifs
}

enum OneOffTaskState {
  UNSTARTED
  STARTED
  FINISHED
}

enum QuestionOptionType {
  DROPDOWN // dropdown selection
  SELECT // for custom selection
  INPUT
}

enum CallLength {
  min25
  min50
}

enum NotifyOption {
  NONE
  BOTH
  OWNER
  TEAMMATE
}

enum OptionYesNo {
  YES
  NO
  NOTSET
}

enum OptionPrivilege {
  PUBLIC
  PRIVATE
}

// model Session {
//   id                 Int       @id @default(autoincrement())
//   createdAt          DateTime  @default(now())
//   updatedAt          DateTime  @updatedAt
//   expiresAt          DateTime?
//   handle             String    @unique
//   user               User?     @relation(fields: [userId], references: [id], onDelete: Cascade)
//   userId             String?
//   hashedSessionToken String?
//   antiCSRFToken      String?
//   publicData         String?
//   privateData        String?
// }

// model MeetingGoal {
//   id        String   @id @default(cuid())
//   fromGoal  Goal[]   @relation("callFromGoal")
//   toGoal    Goal[]   @relation("callToGoal")
//   fromChore Chore[]  @relation("callFromChore")
//   toChore   Chore[]  @relation("callToChore")
//   meeting   Meeting? @relation(fields: [meetingId], references: [id], onDelete: Cascade)
//   meetingId String

//   @@unique([meetingId])
// }

// weekStartDate & weekEndDate are used to identify which period the weekly
// review is for
// model WeekReview {
//   id          String          @id @default(cuid())
//   timeStamp   DateTime        @default(now())
//   wkStartDate DateTime?
//   wkEndDate   DateTime?
//   team        Team            @relation(fields: [teamId], references: [id])
//   teamId      String
//   goalBoard   GoalBoard       @relation("gB", fields: [goalBoardId], references: [id])
//   goalBoardId String
//   owner       User            @relation(fields: [ownerId], references: [id])
//   ownerId     String
//   content     String
//   contentHash String?
//   reaction    ReviewReaction? @relation(fields: [reactionId], references: [id])
//   reactionId  String?         @unique
//   log         Log[]
// }

// model ReviewReaction {
//   id        String      @id @default(cuid())
//   timeStamp DateTime    @default(now())
//   content   String
// contentHash String?
// review    WeekReview?
// }

// model AppFeedback {
//   id              String   @id @default(cuid())
//   timeStamp       DateTime @default(now())
//   user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
//   userId          String
//   requireResponse Boolean // is user expecting a response back
//   message         String
//   emotion         String?
//   about           String? // what is the feedback about
//   pageRef         String // which page the user is on
// }

// model Questionaire {
//   id        String               @id @default(cuid())
//   isActive  Boolean              @default(true)
//   startDate DateTime             @default(now())
//   endDate   DateTime?
//   title     String
//   option    QuestionaireOption[]
//   answer    QuestionaireAnswer[]
//   log       Log[]
// }

// model QuestionaireOption {
//   id       String               @id @default(cuid())
//   type     QuestionOptionType
//   label    String?
//   value    String
//   question Questionaire[]
//   answer   QuestionaireAnswer[]
// }

// model QuestionaireAnswer {
//   id         String             @id @default(cuid())
//   question   Questionaire       @relation(fields: [questionId], references: [id])
//   questionId String
//   timeStamp  DateTime           @default(now())
//   option     QuestionaireOption @relation(fields: [optionId], references: [id])
//   optionId   String
//   user       User               @relation(fields: [userId], references: [id], onDelete: Cascade)
//   userId     String
// }

// Activities are for Timeline page
// Disabled as now user will specify a 'general' task for other activites
// and only tasks will populate the activity timeline
// model Activities {
//   id      String   @id @default(cuid())
//   startAt DateTime
//   endAt   DateTime
//   owner   User     @relation(fields: [ownerId], references: [id], onDelete: Cascade)
//   ownerId String
// }
